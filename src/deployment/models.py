"""Data models for deployment system."""

from __future__ import annotations
from pydantic import BaseModel, Field, field_validator
from typing import List, Dict, Any, Optional, Union
from datetime import datetime
import subprocess


# ============================================================================
# Job Definition Models
# ============================================================================

class JobMetadata(BaseModel):
    """Job metadata."""
    name: str
    version: str = "1.0.0"
    description: str = ""
    tags: List[str] = []


class DeploymentTarget(BaseModel):
    """Where to deploy an agent."""
    target: str  # localhost, remote, container, kubernetes
    host: Optional[str] = None  # For remote
    user: Optional[str] = None  # For remote
    python: Optional[str] = None  # For remote
    workdir: Optional[str] = None  # For remote
    ssh_key: Optional[str] = None  # For remote
    container_name: Optional[str] = None  # For container
    image: Optional[str] = None  # For container
    network: Optional[str] = None  # For container
    namespace: Optional[str] = None  # For kubernetes


class ResourceRequirements(BaseModel):
    """Resource requirements for an agent."""
    cpu: Optional[float] = None
    memory: Optional[str] = None
    gpu: Optional[int] = None


class AgentConfig(BaseModel):
    """Configuration for a single agent."""
    id: str
    type: str  # Agent class name
    module: str  # Python module path
    config: Dict[str, Any] = {}
    deployment: DeploymentTarget
    resources: Optional[ResourceRequirements] = None
    environment: Dict[str, str] = {}


class Connection(BaseModel):
    """Connection between agents."""
    from_: str = Field(alias="from")
    to: Union[str, List[str]]

    class Config:
        populate_by_name = True


class TopologyConfig(BaseModel):
    """Topology configuration."""
    type: str  # hub-spoke, pipeline, dag, mesh, hierarchical

    # Hub-spoke fields
    hub: Optional[str] = None
    spokes: Optional[List[str]] = None

    # Pipeline fields
    stages: Optional[List[str]] = None

    # DAG fields
    connections: Optional[List[Connection]] = None

    # Mesh fields
    agents: Optional[List[str]] = None

    # Hierarchical fields
    root: Optional[str] = None
    levels: Optional[List[Dict[str, Any]]] = None

    @field_validator("type")
    @classmethod
    def validate_topology_type(cls, v):
        """Validate topology type."""
        valid_types = ["hub-spoke", "pipeline", "dag", "mesh", "hierarchical"]
        if v not in valid_types:
            raise ValueError(f"Invalid topology type: {v}. Must be one of {valid_types}")
        return v


class DeploymentConfig(BaseModel):
    """Deployment configuration."""
    strategy: str = "sequential"  # sequential, parallel, staged
    timeout: int = 60
    health_check: Optional[Dict[str, Any]] = None
    ssh: Optional[Dict[str, Any]] = None


class ExecutionConfig(BaseModel):
    """Execution configuration."""
    entry_point: Optional[str] = None
    auto_start: bool = True


class JobDefinition(BaseModel):
    """Complete job definition."""
    job: JobMetadata
    agents: List[AgentConfig]
    topology: TopologyConfig
    deployment: DeploymentConfig
    environment: Dict[str, str] = {}
    execution: Optional[ExecutionConfig] = None

    def get_agent(self, agent_id: str) -> Optional[AgentConfig]:
        """Get agent by ID."""
        for agent in self.agents:
            if agent.id == agent_id:
                return agent
        return None

    def get_agent_ids(self) -> set[str]:
        """Get set of all agent IDs."""
        return {agent.id for agent in self.agents}


# ============================================================================
# Deployment Plan Models
# ============================================================================

class DeploymentPlan(BaseModel):
    """Plan for deploying a job.

    Generated by TopologyResolver based on job topology.
    """
    job_name: str
    stages: List[List[str]]  # List of stages, each stage is list of agent IDs
    agent_urls: Dict[str, str]  # agent_id -> URL
    connections: Dict[str, List[str]]  # agent_id -> list of URLs to connect to

    class Config:
        arbitrary_types_allowed = True


# ============================================================================
# Deployed Job Models
# ============================================================================

class AgentProcess:
    """Wrapper for agent process (local or remote)."""

    def __init__(self, agent_id: str, process: Any):
        self.agent_id = agent_id
        self.process = process
        self.start_time = datetime.now()

    def is_running(self) -> bool:
        """Check if process is running."""
        if isinstance(self.process, subprocess.Popen):
            return self.process.poll() is None
        # For remote/container, implement accordingly
        return True

    def stop(self):
        """Stop the process."""
        if isinstance(self.process, subprocess.Popen):
            self.process.terminate()
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.process.kill()
                self.process.wait()


class DeployedJob:
    """A deployed job with running agents."""

    def __init__(
        self,
        job_id: str,
        definition: JobDefinition,
        agents: Dict[str, AgentProcess],
        urls: Dict[str, str],
        plan: DeploymentPlan
    ):
        self.job_id = job_id
        self.definition = definition
        self.agents = agents  # agent_id -> AgentProcess
        self.urls = urls  # agent_id -> URL
        self.plan = plan
        self.start_time = datetime.now()

    def stop(self):
        """Stop all agents."""
        for agent_id, agent_process in self.agents.items():
            print(f"Stopping {agent_id}...")
            agent_process.stop()

    def get_status(self) -> Dict[str, bool]:
        """Get status of all agents."""
        return {
            agent_id: agent.is_running()
            for agent_id, agent in self.agents.items()
        }
